// SPDX-License-Identifier: GPL-3.0-or-later
// Copyright (C) 2020 Danil Uzlov

#pragma once

#include "rxtd/DataWithLock.h"
#include "rxtd/rainmeter/Rainmeter.h"
#include "sound_processing/ProcessingManager.h"
#include "sound_processing/ProcessingOrchestrator.h"
#include "sound_processing/device_management/CaptureManager.h"
#include "wasapi_wrappers/implementations/MediaDeviceListNotificationClient.h"

namespace rxtd::audio_analyzer {
	class ParentHelper : MovableOnlyBase {
	public:
		using Rainmeter = rainmeter::Rainmeter;
		using OptionMap = option_parsing::OptionMap;
		using MediaDeviceType = wasapi_wrappers::MediaDeviceType;

		struct SnapshotStruct {
			struct LockableData : DataWithLock {
				ProcessingOrchestrator::Snapshot _;
			} data;

			struct LockableDeviceInfo : DataWithLock {
				CaptureManager::Snapshot _;
			} deviceInfo;

			struct LockableDeviceListStrings : DataWithLock {
				string input;
				string output;
			} deviceLists;

			std::atomic<bool> deviceIsAvailable{ false };

			void setThreading(bool value) {
				data.setUseLocking(value);
				deviceInfo.setUseLocking(value);
				deviceLists.setUseLocking(value);
			}
		};

		struct Callbacks {
			string onUpdate;
			string onDeviceChange;
			string onDeviceListChange;
			string onDeviceDisconnected;

			// autogenerated
			friend bool operator==(const Callbacks& lhs, const Callbacks& rhs) {
				return lhs.onUpdate == rhs.onUpdate
					&& lhs.onDeviceChange == rhs.onDeviceChange
					&& lhs.onDeviceListChange == rhs.onDeviceListChange
					&& lhs.onDeviceDisconnected == rhs.onDeviceDisconnected;
			}

			friend bool operator!=(const Callbacks& lhs, const Callbacks& rhs) {
				return !(lhs == rhs);
			}
		};

	private:
		wasapi_wrappers::MediaDeviceEnumerator enumeratorWrapper;

		struct {
			Version version{};
			bool useThreading = false;
			double updateTime{};
		} constFields;

		struct {
			winapi_wrappers::GenericComWrapper<wasapi_wrappers::implementations::MediaDeviceListNotificationClient> notificationClient;
		} threadSafeFields;

		struct ThreadSleepFields : DataWithLock {
			std::condition_variable sleepVariable;
			bool stopRequest = false;
			bool updateRequest = false;
		} threadSleepFields;

		struct MainFields {
			Rainmeter rain;
			Logger logger;
			CaptureManager captureManager;
			ProcessingOrchestrator orchestrator;

			struct {
				CaptureManager::SourceDesc device;
				options::ParamHelper::ProcessingsInfoMap patches;
			} settings;

			Callbacks callbacks;
			bool disconnected = false;
		} mainFields;

		struct RequestFields : DataWithLock {
			std::thread thread;

			struct {
				std::optional<Callbacks> callbacks;
				std::optional<CaptureManager::SourceDesc> device;
				std::optional<options::ParamHelper::ProcessingsInfoMap> patches;
			} settings;

			bool disconnect = false;
		} requestFields;

		SnapshotStruct snapshot;

	public:
		~ParentHelper();

		// throws std::runtime_error on fatal error
		void init(
			Rainmeter _rain,
			Logger _logger,
			const OptionMap& threadingMap,
			option_parsing::OptionParser& parser,
			Version version,
			bool suppressVolumeChange
		);

		void setInvalid();

		void setParams(
			std::optional<Callbacks> callbacks,
			std::optional<CaptureManager::SourceDesc> device,
			std::optional<options::ParamHelper::ProcessingsInfoMap> patches
		);

		SnapshotStruct& getSnapshot() {
			return snapshot;
		}

		void update();

	private:
		void wakeThreadUp();

		// Caller of this function must *NOT* have RequestLock
		// this function joins the thread, which might be waiting on it before finishing
		void stopThread();
		void threadFunction();

		void pUpdate();
		// returns true device format changed, false otherwise
		bool reconnectToDevice();
		void updateProcessings();
		bool updateDeviceListStrings();

		string makeDeviceListString(MediaDeviceType type);
	};
}
