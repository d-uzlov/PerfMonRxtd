/*
 * Copyright (C) 2020 rxtd
 *
 * This Source Code Form is subject to the terms of the GNU General Public
 * License; either version 2 of the License, or (at your option) any later
 * version. If a copy of the GPL was not distributed with this file, You can
 * obtain one at <https://www.gnu.org/licenses/gpl-2.0.html>.
 */

#pragma once
#include "StripedImage.h"
#include "rxtd/DiscreetInterpolator.h"
#include "Color.h"

namespace rxtd::utils {
	class WaveFormDrawer {
	public:
		enum class LineDrawingPolicy {
			eNEVER,
			eBELOW_WAVE,
			eALWAYS,
		};

		struct Colors {
			IntColor background;
			IntColor wave;
			IntColor line;
			IntColor border;

			// autogenerated
			friend bool operator==(const Colors& lhs, const Colors& rhs) {
				return lhs.background == rhs.background
					&& lhs.wave == rhs.wave
					&& lhs.line == rhs.line
					&& lhs.border == rhs.border;
			}

			friend bool operator!=(const Colors& lhs, const Colors& rhs) {
				return !(lhs == rhs);
			}
		};

	private:
		struct MinMax {
			index minPixel{};
			index maxPixel{};

			// autogenerated
			friend bool operator==(const MinMax& lhs, const MinMax& rhs) {
				return lhs.minPixel == rhs.minPixel
					&& lhs.maxPixel == rhs.maxPixel;
			}

			friend bool operator!=(const MinMax& lhs, const MinMax& rhs) {
				return !(lhs == rhs);
			}
		};

		StripedImage<MinMax> minMaxBuffer{};
		Vector2D<IntColor> resultBuffer{};
		DiscreetInterpolator interpolator;

		index width{};
		index height{};

		LineDrawingPolicy lineDrawingPolicy = LineDrawingPolicy::eNEVER;
		bool connected = false;
		index borderSize = 0;
		double fading = 0.0;
		index lineThickness = 1;

		Colors colors{};

		MinMax prev;

	public:
		void setParams(
			bool _connected,
			index _borderSize, double _fading,
			LineDrawingPolicy ldp, index _lineThickness,
			Colors _colors
		) {
			connected = _connected;
			borderSize = _borderSize;
			fading = _fading;
			lineDrawingPolicy = ldp;
			lineThickness = _lineThickness;
			colors = _colors;

			if (lineThickness == 0) {
				lineDrawingPolicy = LineDrawingPolicy::eNEVER;
			}
		}

		void setImageParams(index width, index height, bool stationary);

		void fillSilence();

		void fillStrip(double min, double max);

		[[nodiscard]]
		array2d_view<IntColor> getResultBuffer() const {
			return resultBuffer;
		}

		[[nodiscard]]
		bool isEmpty() const {
			return minMaxBuffer.isEmpty();
		}

		void inflate();

	private:
		void inflateLine(index line, array_span<IntColor> dest, IntColor backgroundColor) const;

		[[nodiscard]]
		bool isWaveAt(index i, index line) const;
	};
}
