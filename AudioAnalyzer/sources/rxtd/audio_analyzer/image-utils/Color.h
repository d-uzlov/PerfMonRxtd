/*
 * Copyright (C) 2019-2020 rxtd
 *
 * This Source Code Form is subject to the terms of the GNU General Public
 * License; either version 2 of the License, or (at your option) any later
 * version. If a copy of the GPL was not distributed with this file, You can
 * obtain one at <https://www.gnu.org/licenses/gpl-2.0.html>.
 */

#pragma once
#include "IntColor.h"

namespace rxtd::utils {
	class Color {
	public:
		enum class Mode {
			eRGB,
			eHSV,
			eHSL,
			eYCBCR,
		};

	private:
		union {
			struct {
				float red = 0.0;
				float green = 0.0;
				float blue = 0.0;
			} rgb;

			struct {
				float hue;
				float sat;
				float val;
			} hsv;

			struct {
				float y;
				float cb;
				float cr;
			} tv;
		} _{};

		float alpha = 1.0f;
		Mode mode = Mode::eRGB;

	public:
		Color() = default;

		Color(float red, float green, float blue, float alpha = 1.0f, Mode mode = Mode::eRGB) :
			alpha(alpha), mode(mode) {
			_.rgb.red = red;
			_.rgb.green = green;
			_.rgb.blue = blue;
		}

		[[nodiscard]]
		static Color parse(sview desc, Color defaultValue = {});

		[[nodiscard]]
		Color operator*(float value) const {
			return {
				_.rgb.red * value,
				_.rgb.green * value,
				_.rgb.blue * value,
				alpha * value,
				mode
			};
		}

		[[nodiscard]]
		Color operator+(const Color& other) const {
			return {
				_.rgb.red + other._.rgb.red,
				_.rgb.green + other._.rgb.green,
				_.rgb.blue + other._.rgb.blue,
				alpha + other.alpha,
				mode
			};
		}

		// autogenerated
		friend bool operator==(const Color& lhs, const Color& rhs) {
			return lhs._.rgb.red == rhs._.rgb.red
				&& lhs._.rgb.green == rhs._.rgb.green
				&& lhs._.rgb.blue == rhs._.rgb.blue
				&& lhs.alpha == rhs.alpha;
		}

		friend bool operator!=(const Color& lhs, const Color& rhs) {
			return !(lhs == rhs);
		}

		[[nodiscard]]
		Color rgb() const {
			switch (mode) {
			case Mode::eRGB: return *this;
			case Mode::eHSV: return hsv2rgb();
			case Mode::eHSL: return hsl2hsv().hsv2rgb();
			case Mode::eYCBCR: return ycbcr2rgb();
			}
			return {};
		}

		[[nodiscard]]
		Color hsv() const {
			switch (mode) {
			case Mode::eRGB: return rgb2hsv();
			case Mode::eHSV: return *this;
			case Mode::eHSL: return hsl2hsv();
			case Mode::eYCBCR: return ycbcr2rgb().rgb2hsv();
			}
			return {};
		}

		[[nodiscard]]
		Color hsl() const {
			switch (mode) {
			case Mode::eRGB: return rgb2hsv().hsv2hsl();
			case Mode::eHSV: return hsv2hsl();
			case Mode::eHSL: return *this;
			case Mode::eYCBCR: return ycbcr2rgb().rgb2hsv().hsv2hsl();
			}
			return {};
		}

		[[nodiscard]]
		Color ycbcr() const {
			switch (mode) {
			case Mode::eRGB: return rgb2ycbcr();
			case Mode::eHSV: return hsv2rgb().rgb2ycbcr();
			case Mode::eHSL: return hsl2hsv().hsv2rgb().rgb2ycbcr();
			case Mode::eYCBCR: return *this;
			}
			return {};
		}

		[[nodiscard]]
		Color convert(Mode _mode) const {
			switch (_mode) {
			case Mode::eRGB: return rgb();
			case Mode::eHSV: return hsv();
			case Mode::eHSL: return hsl();
			case Mode::eYCBCR: return ycbcr();
			}
			return {};
		}

		[[nodiscard]]
		IntColor toIntColor() const {
			if (mode != Mode::eRGB) {
				return rgb().toIntColor();
			}

			IntColor result{};
			result.r = uint8_t(std::clamp<int>(std::lround(_.rgb.red * 255), 0, 255));
			result.g = uint8_t(std::clamp<int>(std::lround(_.rgb.green * 255), 0, 255));
			result.b = uint8_t(std::clamp<int>(std::lround(_.rgb.blue * 255), 0, 255));
			result.a = uint8_t(std::clamp<int>(std::lround(alpha * 255), 0, 255));

			return result;
		}

	private:
		[[nodiscard]]
		Color rgb2hsv() const;

		[[nodiscard]]
		Color hsv2hsl() const;

		[[nodiscard]]
		Color hsl2hsv() const;

		[[nodiscard]]
		Color hsv2rgb() const;

		[[nodiscard]]
		Color rgb2ycbcr() const;

		[[nodiscard]]
		Color ycbcr2rgb() const;
	};
}
