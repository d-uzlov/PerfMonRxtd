// SPDX-License-Identifier: GPL-3.0-or-later
// Copyright (C) 2019 Danil Uzlov

/*
 Handler life cycle
 First of all, handler should parse its parameters. It happens in the method #parseParams(),
 which is called on an empty object.
 If params are invalid, then parseParams should return invalid object,
 so that handler with these params will not be created.
 Then the main life cycle happens:
 1. Function #setParams is called.
		This function should only save parameters, any external info in the moment of time when this function is called is considered invalid
 2. Function #vConfigure is called
		At this point handler should do all calculations required to work.
		Handler may call #vConfigure to get external info
		If something fails, handler should return invalid object, and the it is invalidated until next params change
 3. vProcess happens in the loop
 4. Data is accessed from other handlers and child measures.
 */

#pragma once
#include <chrono>
#include <utility>

#include "ExternalMethods.h"
#include "rxtd/audio_analyzer/Version.h"
#include "rxtd/buffer_printer/BufferPrinter.h"
#include "rxtd/option_parsing/Option.h"
#include "rxtd/option_parsing/OptionParser.h"
#include "rxtd/rainmeter/Rainmeter.h"
#include "rxtd/std_fixes/AnyContainer.h"
#include "rxtd/std_fixes/Vector2D.h"


namespace rxtd::audio_analyzer::handler {
	class HandlerBase : VirtualDestructorBase {
	public:
		using Option = option_parsing::Option;
		using OptionMap = option_parsing::OptionMap;
		using OptionList = option_parsing::OptionList;
		using OptionSequence = option_parsing::OptionSequence;
		using Rainmeter = rainmeter::Rainmeter;
		using ParamsContainer = std_fixes::AnyContainer;
		using ExternalData = ExternalMethods::ExternalData;
		using clock = std::chrono::high_resolution_clock;
		static_assert(clock::is_steady);
		using BufferPrinter = buffer_printer::BufferPrinter;
		template<typename T>
		using Vector2D = std_fixes::Vector2D<T>;
		using Parser = option_parsing::OptionParser;

		/// <summary>
		/// Thrown when a handler generated too many values.
		/// For example, this can often happen with TimeResampler handler,
		/// which has an option for how often it pushes new array of values.
		/// </summary>
		class TooManyValuesException : public std::runtime_error {
			string sourceName;
		public:
			explicit TooManyValuesException(string sourceName) : runtime_error(""), sourceName(std::move(sourceName)) {}

			[[nodiscard]]
			sview getSourceName() const {
				return sourceName;
			}
		};

		/// <summary>
		/// Struct that describes values that a handler generates.
		/// </summary>
		struct DataSize {
			index valuesCount{};
			index layersCount{};
			/// <summary>
			/// Describes how much time (in audio wave point)
			/// need to pass for one array of a layer to be generated
			/// </summary>
			std::vector<index> eqWaveSizes;

			DataSize() = default;

			DataSize(index valuesCount, std::vector<index> eqWaveSizes) :
				valuesCount(valuesCount),
				eqWaveSizes(std::move(eqWaveSizes)) {
				layersCount = static_cast<index>(this->eqWaveSizes.size());
			}

			[[nodiscard]]
			bool isEmpty() const {
				return eqWaveSizes.empty() || valuesCount == 0;
			}

			friend bool operator==(const DataSize& lhs, const DataSize& rhs) {
				return lhs.valuesCount == rhs.valuesCount
					&& lhs.eqWaveSizes == rhs.eqWaveSizes;
			}

			friend bool operator!=(const DataSize& lhs, const DataSize& rhs) { return !(lhs == rhs); }
		};

	protected:
		struct Configuration {
			HandlerBase* sourcePtr = nullptr;
			index sampleRate{};
			Version version{};

			// autogenerated
			friend bool operator==(const Configuration& lhs, const Configuration& rhs) {
				return lhs.sourcePtr == rhs.sourcePtr
					&& lhs.sampleRate == rhs.sampleRate
					&& lhs.version == rhs.version;
			}

			friend bool operator!=(const Configuration& lhs, const Configuration& rhs) {
				return !(lhs == rhs);
			}
		};

	private:
		DataSize _inputDataSize;
		Configuration _configuration{};

		struct HandlerBaseData {
			string name;
			DataSize size;

			struct {
				struct LayerCache {
					mutable std::vector<array_view<float>> chunksView;
					std::vector<index> offsets;
				};

				std::vector<LayerCache> inflatableCache;
				mutable bool valid = false;
			} layers;

			std::vector<float> buffer;
			Vector2D<float> lastResults;


			void inflateLayers() const;

			void clearChunks();


			[[nodiscard]]
			array_span<float> pushLayer(index layer);
		} _data;


	public:
		struct HandlerMetaInfo {
			using handlerUptr = std::unique_ptr<HandlerBase>;
			using TransformFun = handlerUptr(*)(handlerUptr old);

			ParamsContainer params;
			index sourcesCount = 0;
			// std::vector<istring> sources;
			TransformFun transform = [](handlerUptr ptr) -> handlerUptr { return {}; };
			ExternalMethods externalMethods{};
		};

		/// <summary>
		/// Thrown when a handler can't parse it's options
		/// or when the option values are invalid.
		/// </summary>
		class InvalidOptionsException : public std::runtime_error {
		public:
			explicit InvalidOptionsException() : runtime_error("") {}
		};


		struct ParamParseContext {
			const OptionMap& options;
			Logger& log;
			const Rainmeter& rain;
			Version version;
			Parser& parser;

			ParamParseContext(const OptionMap& options, Logger& log, const Rainmeter& rain, const Version& version, Parser& parser) :
				options(options), log(log), rain(rain), version(version), parser(parser) {}
		};

		/// <summary>
		/// Creates all the necessary meta info to create an object of a class, patch it and use it.
		/// Can throw InvalidOptionsException.
		/// </summary>
		/// <typeparam name="Type">Type of the handler implementation. Must be a descendant from HandlerBase class.</typeparam>
		/// <returns>Valid HandlerMetaInfo object.</returns>
		template<typename Type>
		[[nodiscard]]
		static HandlerMetaInfo createMetaForClass(ParamParseContext& context) noexcept(false) {
			using HandlerType = Type;
			HandlerMetaInfo meta;

			meta.transform = patchHandlerImpl<HandlerType>;

			HandlerType instance;
			HandlerBase& ref = instance;

			context.parser.setLogger(context.log);

			meta.params = ref.vParseParams(context);
			meta.externalMethods.finish = ref.vGetExt_finish();
			meta.externalMethods.getProp = ref.vGetExt_getProp();
			meta.sourcesCount = ref.vGetSourcesCount();

			return meta;
		}

	protected:
		[[nodiscard]]
		virtual ExternalMethods::FinishMethodType vGetExt_finish() const {
			return [](const ExternalData&, const ExternalMethods::CallContext&) {};
		}

		[[nodiscard]]
		virtual ExternalMethods::GetPropMethodType vGetExt_getProp() const {
			return [](const ExternalData&, isview, const ExternalMethods::CallContext&) -> bool {
				return {};
			};
		}

		[[nodiscard]]
		virtual index vGetSourcesCount() const {
			return 0;
		}

		/// <summary>
		/// Reads options from map and creates a ParamsContainer object.
		/// Implementation is allowed to throw InvalidOptionsException.
		/// </summary>
		/// <returns>ParamsContainer, that is valid for vConfigure call on the same object.</returns>
		[[nodiscard]]
		virtual ParamsContainer vParseParams(ParamParseContext& context) const noexcept(false) = 0;

	public:
		struct ProcessContext {
			array_view<float> wave;
			array_view<float> originalWave;
			clock::time_point killTime;
		};

		struct Snapshot {
			Vector2D<float> values;
			ExternalData handlerSpecificData;
		};

		void process(ProcessContext context, Snapshot& snapshot) {
			_data.clearChunks();
			vProcess(context, snapshot.handlerSpecificData);
			fillSnapshot(snapshot);
		}

	protected:
		// if handler is potentially heavy,
		// handler should try to return control to caller
		// when time is more than context.killTime
		virtual void vProcess(ProcessContext context, ExternalData& handlerSpecificData) = 0;

		struct ConfigurationResult {
			bool success = false;
			DataSize dataSize;

			ConfigurationResult() = default;

			ConfigurationResult(DataSize dataSize) : success(true), dataSize(std::move(dataSize)) { }

			ConfigurationResult(index valuesCount, std::vector<index> eqWaveSizes) :
				ConfigurationResult(DataSize{ valuesCount, std::move(eqWaveSizes) }) { }
		};

		[[nodiscard]]
		virtual ConfigurationResult vConfigure(
			const ParamsContainer& _params, Logger& cl,
			ExternalData& externalData
		) = 0;

		// should return true when params are the same
		[[nodiscard]]
		virtual bool vCheckSameParams(const ParamsContainer& p) const = 0;

	public:
		// returns true on success, false on invalid handler
		[[nodiscard]]
		bool patch(
			sview name,
			const ParamsContainer& params,
			HandlerBase* source,
			index sampleRate, Version version,
			Logger& cl,
			Snapshot& snapshot
		);

		// following public members are public for access between handlers
		[[nodiscard]]
		const DataSize& getDataSize() const {
			return _data.size;
		}

		[[nodiscard]]
		array_view<array_view<float>> getChunks(index layer) const {
			if (layer >= static_cast<index>(_data.size.eqWaveSizes.size())) {
				return {};
			}

			_data.inflateLayers();
			return _data.layers.inflatableCache[static_cast<size_t>(layer)].chunksView;
		}

		// returns saved data from previous iteration
		[[nodiscard]]
		array_view<float> getSavedData(index layer) const {
			if (layer >= static_cast<index>(_data.size.eqWaveSizes.size())) {
				return {};
			}

			return _data.lastResults[layer];
		}

		[[nodiscard]]
		const Configuration& getConfiguration() const {
			return _configuration;
		}

	protected:
		template<typename Params>
		static bool compareParamsEquals(const Params& p1, const ParamsContainer& p2) {
			return p1 == p2.cast<Params>();
		}

		template<typename DataStructType, auto methodPtr>
		static ExternalMethods::FinishMethodType wrapExternalFinish() {
			static_assert(
				std::is_invocable<decltype(methodPtr), const DataStructType&, const ExternalMethods::CallContext&>::value,
				"Method doesn't match the required signature."
			);
			return [](const ExternalData& dataWrapper, const ExternalMethods::CallContext& context) {
				return methodPtr(dataWrapper.cast<DataStructType>(), context);
			};
		}

		template<typename DataStructType, auto methodPtr>
		static ExternalMethods::GetPropMethodType wrapExternalGetProp() {
			static_assert(
				std::is_invocable_r<bool, decltype(methodPtr), const DataStructType&, isview, const ExternalMethods::CallContext&>::value,
				"Method doesn't match the required signature."
			);
			return [](
				const ExternalData& dataWrapper,
				isview prop,
				const ExternalMethods::CallContext& context
			) {
				return methodPtr(dataWrapper.cast<DataStructType>(), prop, context);
			};
		}

		[[nodiscard]]
		array_span<float> pushLayer(index layer) {
			return _data.pushLayer(layer);
		}

		static index legacy_parseIndexProp(const isview& request, const isview& propName, index endBound) {
			return legacy_parseIndexProp(request, propName, 0, endBound);
		}

		static index legacy_parseIndexProp(
			const isview& request,
			const isview& propName,
			index minBound, index endBound
		);

	private:
		void fillSnapshot(Snapshot& snapshot) {
			for (index layer = 0; layer < static_cast<index>(_data.size.eqWaveSizes.size()); layer++) {
				auto& offsets = _data.layers.inflatableCache[static_cast<size_t>(layer)].offsets;
				if (!offsets.empty()) {
					const auto lastChunk = array_view<float>{ _data.buffer.data() + offsets.back(), _data.size.valuesCount };
					snapshot.values[layer].copyFrom(lastChunk);
				} else {
					snapshot.values[layer].copyFrom(_data.lastResults[layer]);
				}
			}
		}

		template<typename Type>
		[[nodiscard]]
		static std::unique_ptr<HandlerBase> patchHandlerImpl(std::unique_ptr<HandlerBase> handlerPtr) {
			using HandlerType = Type;

			if (dynamic_cast<HandlerType*>(handlerPtr.get()) == nullptr) {
				handlerPtr = std::make_unique<HandlerType>();
			}

			return handlerPtr;
		}
	};
}
