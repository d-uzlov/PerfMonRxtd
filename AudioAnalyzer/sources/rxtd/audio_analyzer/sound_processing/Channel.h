// SPDX-License-Identifier: GPL-3.0-or-later
// Copyright (C) 2019 Danil Uzlov

#pragma once

namespace rxtd::audio_analyzer {
	enum class Channel {
		eFRONT_LEFT,
		eFRONT_RIGHT,
		eCENTER,
		eCENTER_BACK,
		eLOW_FREQUENCY,
		eBACK_LEFT,
		eBACK_RIGHT,
		eSIDE_LEFT,
		eSIDE_RIGHT,
		eAUTO,
	};

	class ChannelLayout {
		sview name = {};
		std::map<Channel, index> channelMap;
		std::vector<Channel> channelOrder;

	public:
		ChannelLayout() = default;
		ChannelLayout(sview name, std::vector<std::optional<Channel>> channels);

		[[nodiscard]]
		sview getName() const {
			return name;
		}

		[[nodiscard]]
		std::optional<index> indexOf(Channel channel) const;

		[[nodiscard]]
		bool contains(Channel channel) const {
			return indexOf(channel).has_value();
		}

		[[nodiscard]]
		array_view<Channel> getOrdered() const {
			return channelOrder;
		}

		[[nodiscard]]
		array_view<Channel> ordered() const {
			return channelOrder;
		}

		// autogenerated
		friend bool operator==(const ChannelLayout& lhs, const ChannelLayout& rhs) {
			return lhs.name == rhs.name
				&& lhs.channelMap == rhs.channelMap
				&& lhs.channelOrder == rhs.channelOrder;
		}

		friend bool operator!=(const ChannelLayout& lhs, const ChannelLayout& rhs) {
			return !(lhs == rhs);
		}
	};

	class ChannelUtils {
	public:
		static std::optional<Channel> parse(isview string);

		[[nodiscard]]
		static sview getTechnicalName(Channel channel);

		[[nodiscard]]
		static sview getHumanName(Channel channel);

		[[nodiscard]]
		static ChannelLayout parseLayout(uint32_t bitMask, bool forbid5Point1Surround);
	};
}
