/*
 * Copyright (C) 2019-2020 rxtd
 *
 * This Source Code Form is subject to the terms of the GNU General Public
 * License; either version 2 of the License, or (at your option) any later
 * version. If a copy of the GPL was not distributed with this file, You can
 * obtain one at <https://www.gnu.org/licenses/gpl-2.0.html>.
 */

/*
 Handler life cycle
 First of all, handler should parse its parameters. It happens in the method #parseParams(),
 which is called on an empty object.
 If params are invalid, then parseParams should return invalid object,
 so that handler with these params will not be created.
 Then the main life cycle happens:
 1. Function #setParams is called.
		This function should only save parameters, any external info in the moment of time when this function is called is considered invalid
 2. Function #vConfigure is called
		At this point handler should do all calculations required to work.
		Handler may call #vConfigure to get external info
		If something fails, handler should return invalid object, and the it is invalidated until next params change
 3. vProcess happens in the loop
 4. Data is accessed from other handlers and child measures.
 */

#pragma once
#include <any>
#include <chrono>
#include <utility>

#include "BufferPrinter.h"
#include "Vector2D.h"
#include "../../Version.h"
#include "option-parsing/OptionMap.h"
#include "rainmeter/Rainmeter.h"

namespace rxtd::audio_analyzer {
	class SoundHandlerBase;

	class HandlerFinder {
	public:
		virtual ~HandlerFinder() = default;

		[[nodiscard]]
		virtual SoundHandlerBase* getHandler(isview id) const = 0;
	};

	class SoundHandlerBase : VirtualDestructorBase {
	public:
		using Option = common::options::Option;
		using OptionMap = common::options::OptionMap;
		using OptionList = common::options::OptionList;
		using Rainmeter = common::rainmeter::Rainmeter;
		using Logger = common::rainmeter::Logger;
		using clock = std::chrono::high_resolution_clock;
		static_assert(clock::is_steady);
		using BufferPrinter = common::buffer_printer::BufferPrinter;

		class TooManyValuesException : public std::runtime_error {
			string sourceName;
		public:
			explicit TooManyValuesException(string sourceName) : runtime_error(""), sourceName(std::move(sourceName)) {}

			[[nodiscard]]
			sview getSourceName() const {
				return sourceName;
			}
		};

		struct DataSize {
			index valuesCount{};
			index layersCount{};
			std::vector<index> eqWaveSizes;

			DataSize() = default;

			DataSize(index valuesCount, std::vector<index> _eqWaveSizes) :
				valuesCount(valuesCount),
				eqWaveSizes(std::move(_eqWaveSizes)) {
				layersCount = eqWaveSizes.size();
			}

			[[nodiscard]]
			bool isEmpty() const {
				return eqWaveSizes.empty() || valuesCount == 0;
			}
		};

		struct ExternCallContext {
			Version version{};
			sview channelName{};
			sview filePrefix{};
		};

		struct ProcessContext {
			array_view<float> wave;
			array_view<float> originalWave;
			clock::time_point killTime;
		};

		class ParamsContainer {
			std::any erasedParams;

		public:
			template<typename T>
			T& clear() {
				erasedParams = T{};
				return cast<T>();
			}

			template<typename T>
			T& cast() {
				return *std::any_cast<T>(&erasedParams);
			}

			template<typename T>
			const T& cast() const {
				return *std::any_cast<T>(&erasedParams);
			}

			// prevent automatic type conversions
			ParamsContainer() = default;
		};

		class ExternalData {
			std::any erasedData;

		public:
			template<typename T>
			T& clear() {
				erasedData = T{};
				return cast<T>();
			}

			template<typename T>
			T& cast() {
				return *std::any_cast<T>(&erasedData);
			}

			template<typename T>
			const T& cast() const {
				return *std::any_cast<T>(&erasedData);
			}

			// prevent automatic type conversions
			ExternalData() = default;
		};

		struct ExternalMethods {
			using FinishMethodType = void(*)(const ExternalData& data, const ExternCallContext& context);
			using GetPropMethodType = bool(*)(
				const ExternalData& data,
				isview prop,
				BufferPrinter& printer,
				const ExternCallContext& context
			);

			FinishMethodType finish = nullptr;

			// returns true if such prop exists, false otherwise
			GetPropMethodType getProp = nullptr;

			// autogenerated
			friend bool operator==(const ExternalMethods& lhs, const ExternalMethods& rhs) {
				return lhs.finish == rhs.finish
					&& lhs.getProp == rhs.getProp;
			}

			friend bool operator!=(const ExternalMethods& lhs, const ExternalMethods& rhs) {
				return !(lhs == rhs);
			}
		};

		struct ParseResult {
			bool valid = false;
			ParamsContainer params;
			std::vector<istring> sources;
			ExternalMethods externalMethods{};

			ParseResult() : ParseResult(false) {}

			explicit ParseResult(bool isValid) {
				valid = isValid;
			}
		};

		struct Snapshot {
			utils::Vector2D<float> values;
			ExternalData handlerSpecificData;
		};

	protected:
		struct Configuration {
			SoundHandlerBase* sourcePtr = nullptr;
			index sampleRate{};
			Version version{};

			// autogenerated
			friend bool operator==(const Configuration& lhs, const Configuration& rhs) {
				return lhs.sourcePtr == rhs.sourcePtr
					&& lhs.sampleRate == rhs.sampleRate
					&& lhs.version == rhs.version;
			}

			friend bool operator!=(const Configuration& lhs, const Configuration& rhs) {
				return !(lhs == rhs);
			}
		};

		struct ConfigurationResult {
			bool success = false;
			DataSize dataSize;

			ConfigurationResult() = default;

			ConfigurationResult(DataSize dataSize): success(true), dataSize(std::move(dataSize)) { }

			ConfigurationResult(index valuesCount, std::vector<index> eqWaveSizes):
				ConfigurationResult(DataSize{ valuesCount, std::move(eqWaveSizes) }) { }
		};

	private:
		struct LayerCache {
			mutable std::vector<array_view<float>> chunksView;
			std::vector<index> offsets;
		};

		string handlerName;
		bool _anyChanges = false;
		DataSize _dataSize;
		mutable bool _layersAreValid = false;
		std::vector<float> _buffer;
		std::vector<LayerCache> _layers;
		utils::Vector2D<float> _lastResults;

		Configuration _configuration{};

	public:
		template<typename Type>
		[[nodiscard]]
		static std::unique_ptr<SoundHandlerBase> patchHandlerImpl(std::unique_ptr<SoundHandlerBase> handlerPtr) {
			using HandlerType = Type;

			SoundHandlerBase* ptr = dynamic_cast<HandlerType*>(handlerPtr.get());
			if (ptr == nullptr) {
				ptr = new HandlerType();
				handlerPtr = std::unique_ptr<SoundHandlerBase>{ ptr };
			}

			return handlerPtr;
		}

		[[nodiscard]]
		virtual ParseResult
		parseParams(const OptionMap& om, Logger& cl, const Rainmeter& rain, Version version) const = 0;

		// returns true on success, false on invalid handler
		[[nodiscard]]
		bool patch(
			string name,
			const ParamsContainer& params, const std::vector<istring>& sources,
			index sampleRate, Version version,
			HandlerFinder& hf, Logger& cl,
			Snapshot& snapshot
		);

		void finishConfiguration() {
			_anyChanges = false;
		}

		void process(ProcessContext context, Snapshot& snapshot) {
			clearChunks();

			vProcess(context, snapshot.handlerSpecificData);

			for (index layer = 0; layer < index(_dataSize.eqWaveSizes.size()); layer++) {
				auto& offsets = _layers[layer].offsets;
				if (!offsets.empty()) {
					const auto lastChunk = array_view<float>{ _buffer.data() + offsets.back(), _dataSize.valuesCount };
					snapshot.values[layer].copyFrom(lastChunk);
				} else {
					snapshot.values[layer].copyFrom(_lastResults[layer]);
				}
			}
		}

		// following public members are public for access between handlers
		[[nodiscard]]
		const DataSize& getDataSize() const {
			return _dataSize;
		}

		[[nodiscard]]
		virtual index getStartingLayer() const {
			return _configuration.sourcePtr == nullptr ? 0 : _configuration.sourcePtr->getStartingLayer();
		}

		[[nodiscard]]
		array_view<array_view<float>> getChunks(index layer) const {
			if (layer >= index(_dataSize.eqWaveSizes.size())) {
				return {};
			}

			inflateLayers();
			return _layers[layer].chunksView;
		}

		// returns saved data from previous iteration
		[[nodiscard]]
		array_view<float> getSavedData(index layer) const {
			if (layer >= index(_dataSize.eqWaveSizes.size())) {
				return {};
			}

			return _lastResults[layer];
		}


	protected:
		template<typename Params>
		static bool compareParamsEquals(const Params& p1, const ParamsContainer& p2) {
			return p1 == p2.cast<Params>();
		}

		template<typename DataStructType, auto methodPtr>
		static auto wrapExternalMethod() {
			if constexpr (std::is_invocable<
					decltype(methodPtr),
					const DataStructType&,
					const ExternCallContext&>::value
			) {
				return [](const ExternalData& dataWrapper, const ExternCallContext& context) {
					return methodPtr(dataWrapper.cast<DataStructType>(), context);
				};
			} else if constexpr (
				std::is_invocable_r<
					bool,
					decltype(methodPtr),
					const DataStructType&, isview, BufferPrinter&, const ExternCallContext&>::value
			) {
				return [](
					const ExternalData& dataWrapper,
					isview prop,
					BufferPrinter& bp,
					const ExternCallContext& context
				) {
					return methodPtr(dataWrapper.cast<DataStructType>(), prop, bp, context);
				};
			} else {
				static_assert(false, L"wrapExternalMethod: unsupported method");
			}
		}

		// should return true when params are the same
		[[nodiscard]]
		virtual bool checkSameParams(const ParamsContainer& p) const = 0;

		[[nodiscard]]
		virtual ConfigurationResult vConfigure(
			const ParamsContainer& _params, Logger& cl,
			ExternalData& externalData
		) = 0;

		[[nodiscard]]
		const Configuration& getConfiguration() const {
			return _configuration;
		}

		[[nodiscard]]
		array_span<float> pushLayer(index layer) {
			const index offset = index(_buffer.size());

			// Prevent handlers from producing too much data
			// see: https://github.com/d-uzlov/Rainmeter-Plugins-by-rxtd/issues/4
			if (offset + _dataSize.valuesCount > 1'000'000) {
				throw TooManyValuesException{ handlerName };
			}

			_buffer.resize(offset + _dataSize.valuesCount);
			_layersAreValid = false;

			_layers[layer].offsets.push_back(offset);

			return { _buffer.data() + offset, _dataSize.valuesCount };
		}

		// if handler is potentially heavy,
		// handler should try to return control to caller
		// when time is more than context.killTime
		virtual void vProcess(ProcessContext context, ExternalData& handlerSpecificData) = 0;

		static index legacy_parseIndexProp(const isview& request, const isview& propName, index endBound) {
			return legacy_parseIndexProp(request, propName, 0, endBound);
		}

		static index legacy_parseIndexProp(
			const isview& request,
			const isview& propName,
			index minBound, index endBound
		);

	private:
		void inflateLayers() const {
			if (_layersAreValid) {
				return;
			}

			for (auto& data : _layers) {
				data.chunksView.resize(data.offsets.size());
				for (index i = 0; i < index(data.offsets.size()); i++) {
					data.chunksView[i] = { _buffer.data() + data.offsets[i], _dataSize.valuesCount };
				}
			}

			_layersAreValid = true;
		}

		void clearChunks() {
			for (index layer = 0; layer < _dataSize.layersCount; layer++) {
				auto& offsets = _layers[layer].offsets;
				if (!offsets.empty()) {
					_lastResults[layer].copyFrom({ _buffer.data() + offsets.back(), _dataSize.valuesCount });
				}
				offsets.clear();
			}

			_layersAreValid = false;

			_buffer.clear();
		}
	};
}
