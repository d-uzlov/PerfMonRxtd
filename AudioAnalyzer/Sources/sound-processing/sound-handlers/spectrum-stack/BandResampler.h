/*
 * Copyright (C) 2019-2020 rxtd
 *
 * This Source Code Form is subject to the terms of the GNU General Public
 * License; either version 2 of the License, or (at your option) any later
 * version. If a copy of the GPL was not distributed with this file, You can
 * obtain one at <https://www.gnu.org/licenses/gpl-2.0.html>.
 */

#pragma once
#include "FftAnalyzer.h"
#include "../SoundHandler.h"
#include "ResamplerProvider.h"

namespace rxtd::audio_analyzer {
	class BandResampler final : public ResamplerProvider {
	public:
		struct Params {
		private:
			friend BandResampler;

			istring fftId;
			index minCascade;
			index maxCascade;

			std::vector<float> bandFreqs;

			bool legacy_proportionalValues;
			bool includeDC;

			// autogenerated
			friend bool operator==(const Params& lhs, const Params& rhs) {
				return lhs.fftId == rhs.fftId
					&& lhs.minCascade == rhs.minCascade
					&& lhs.maxCascade == rhs.maxCascade
					&& lhs.bandFreqs == rhs.bandFreqs
					&& lhs.legacy_proportionalValues == rhs.legacy_proportionalValues
					&& lhs.includeDC == rhs.includeDC;
			}

			friend bool operator!=(const Params& lhs, const Params& rhs) {
				return !(lhs == rhs);
			}
		};

	private:
		struct CascadeInfo {
			std::vector<float> magnitudes;
			std::vector<float> weights;

			void setSize(index size) {
				magnitudes.resize(size);
				weights.resize(size);
			}
		};

		Params params{ };

		index samplesPerSec{ };

		std::vector<float> bandFreqMultipliers{ };
		index startCascade = 0;
		index endCascade = 0;
		index bandsCount = 0;

		std::vector<CascadeInfo> cascadesInfo{ };

		bool cascadeInfoIsCalculated = false;
		bool changed = true;

	public:
		static std::optional<Params> parseParams(
			const utils::OptionMap& optionMap,
			utils::Rainmeter::Logger& cl,
			utils::Rainmeter& rain
		);

		void setParams(const Params& params, Channel channel);

		void setSamplesPerSec(index value) override;
		void reset() override;

		void _process(const DataSupplier& dataSupplier) override;
		void _finish(const DataSupplier& dataSupplier) override;

		array_view<float> getData(index layer) const override;
		index getLayersCount() const override;

		bool getProp(const isview& prop, utils::BufferPrinter& printer) const override;

		index getStartingLayer() const override {
			return startCascade;
		}

		index getEndCascade() const {
			return endCascade;
		}

		array_view<float> getBandWeights(index cascade) const;
		array_view<float> getBaseFreqs() const; // todo unused

		const BandResampler* getResampler(const DataSupplier& dataSupplier) const override {
			return this;
		}

	private:
		void updateValues(const DataSupplier& dataSupplier);
		void sampleData(const FftAnalyzer& source);
		void sampleCascade(array_view<float> fftData, array_span<float> result, double binWidth, index fftBinsCount);

		static std::optional<std::vector<float>> parseFreqList(
			const utils::OptionList& bounds,
			utils::Rainmeter::Logger& cl,
			const utils::Rainmeter& rain
		);

		void computeCascadesInfo(index fftSize, index cascadesCount);
		void calculateCascadeWeights(array_span<float> result, index fftBinsCount, double binWidth);

		void legacy_generateBandMultipliers();
	};
}
