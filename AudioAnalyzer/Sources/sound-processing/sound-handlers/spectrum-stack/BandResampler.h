/*
 * Copyright (C) 2019-2020 rxtd
 *
 * This Source Code Form is subject to the terms of the GNU General Public
 * License; either version 2 of the License, or (at your option) any later
 * version. If a copy of the GPL was not distributed with this file, You can
 * obtain one at <https://www.gnu.org/licenses/gpl-2.0.html>.
 */

#pragma once
#include "FftAnalyzer.h"
#include "../SoundHandler.h"
#include "ResamplerProvider.h"
#include "Vector2D.h"

namespace rxtd::audio_analyzer {
	class BandResampler final : public ResamplerProvider {
	public:
		struct Params {
			index minCascade{ };
			index maxCascade{ };

			std::vector<float> bandFreqs;

			bool legacy_proportionalValues{ };
			bool includeDC{ };

			// autogenerated
			friend bool operator==(const Params& lhs, const Params& rhs) {
				return lhs.minCascade == rhs.minCascade
					&& lhs.maxCascade == rhs.maxCascade
					&& lhs.bandFreqs == rhs.bandFreqs
					&& lhs.legacy_proportionalValues == rhs.legacy_proportionalValues
					&& lhs.includeDC == rhs.includeDC;
			}

			friend bool operator!=(const Params& lhs, const Params& rhs) {
				return !(lhs == rhs);
			}
		};

	private:
		Params params{ };

		FftAnalyzer* fftSource = nullptr;

		std::vector<float> legacy_bandFreqMultipliers{ };
		utils::Vector2D<float> layerWeights;
		utils::Vector2D<float> bandWeights;

		index startCascade = 0;
		index endCascade = 0;
		index bandsCount = 0;

	public:
		[[nodiscard]]
		bool checkSameParams(const std::any& p) const override {
			return compareParamsEquals(params, p);
		}

		void setParams(const std::any& p) override {
			params = std::any_cast<Params>(p);
		}

		[[nodiscard]]
		ParseResult parseParams(
			const OptionMap& om, Logger& cl, const Rainmeter& rain,
			index legacyNumber
		) const override;

	private:
		static std::vector<float> parseFreqList(sview listId, const Rainmeter& rain);

	protected:
		[[nodiscard]]
		ConfigurationResult vConfigure(Logger& cl) override;

	public:
		void vProcess(array_view<float> wave, clock::time_point killTime) override;

		[[nodiscard]]
		index getStartingLayer() const override {
			return startCascade;
		}

		[[nodiscard]]
		index getEndCascade() const {
			return endCascade;
		}

		[[nodiscard]]
		array_view<float> getLayerWeights(index cascade) const {
			return layerWeights[cascade];
		}

		[[nodiscard]]
		array_view<float> getBandWeights(index band) const {
			return bandWeights[band];
		}

		BandResampler* getResampler() override {
			return this;
		}

		bool vGetProp(const isview& prop, utils::BufferPrinter& printer) const override;

	private:
		void sampleCascade(array_view<float> source, array_span<float> dest, double binWidth);

		// depends on fft size and sample rate
		void computeWeights(index fftSize);
		void computeCascadeWeights(array_span<float> result, index fftBinsCount, double binWidth);

		void legacy_generateBandMultipliers();
	};
}
