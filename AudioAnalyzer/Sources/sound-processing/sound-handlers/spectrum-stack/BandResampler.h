/*
 * Copyright (C) 2019 rxtd
 *
 * This Source Code Form is subject to the terms of the GNU General Public
 * License; either version 2 of the License, or (at your option) any later
 * version. If a copy of the GPL was not distributed with this file, You can
 * obtain one at <https://www.gnu.org/licenses/gpl-2.0.html>.
 */

#pragma once
#include "FftAnalyzer.h"
#include "../SoundHandler.h"

namespace rxtd::audio_analyzer {
	class BandResampler;

	class ResamplerProvider : public SoundHandler {
	public:
		virtual const BandResampler* getResampler() const = 0;
	};

	class BandResampler final : public ResamplerProvider {
	public:
		struct Params {
		private:
			friend BandResampler;

			istring fftId;
			layer_t minCascade;
			layer_t maxCascade;

			std::vector<double> bandFreqs;

			bool legacy_proportionalValues;
			bool includeDC;

			// autogenerated
			friend bool operator==(const Params& lhs, const Params& rhs) {
				return lhs.fftId == rhs.fftId
					&& lhs.minCascade == rhs.minCascade
					&& lhs.maxCascade == rhs.maxCascade
					&& lhs.bandFreqs == rhs.bandFreqs
					&& lhs.legacy_proportionalValues == rhs.legacy_proportionalValues
					&& lhs.includeDC == rhs.includeDC;
			}

			friend bool operator!=(const Params& lhs, const Params& rhs) {
				return !(lhs == rhs);
			}
		};

	private:
		struct CascadeInfo {
			std::vector<float> magnitudes;
			std::vector<float> weights;

			void setSize(index size) {
				magnitudes.resize(size);
				weights.resize(size);
			}
		};

		Params params{ };

		index samplesPerSec{ };

		std::vector<double> bandFreqMultipliers{ };
		layer_t startCascade = 0;
		layer_t endCascade = 0;
		index bandsCount = 0;

		std::vector<CascadeInfo> cascadesInfo{ };

		bool cascadeInfoIsCalculated = false;
		bool changed = true;

		mutable string propString{ };

	public:
		static std::optional<Params> parseParams(
			const utils::OptionMap& optionMap,
			utils::Rainmeter::Logger& cl,
			utils::Rainmeter& rain
		);

		void setParams(Params _params, Channel channel);

		void setSamplesPerSec(index value) override;
		void reset() override;

		void _process(const DataSupplier& dataSupplier) override;
		void _finish(const DataSupplier& dataSupplier) override;

		array_view<float> getData(layer_t layer) const override;
		layer_t getLayersCount() const override;

		const wchar_t* getProp(const isview& prop) const override;

		const BandResampler* getResampler() const override {
			return this;
		}

		layer_t getStartingLayer() const override {
			return startCascade;
		}

		layer_t getEndCascade() const {
			return endCascade;
		}

		array_view<float> getBandWeights(layer_t cascade) const;
		array_view<double> getBaseFreqs() const;

	private:
		void updateValues(const DataSupplier& dataSupplier);
		void sampleData(const FftAnalyzer& source);

		static std::optional<std::vector<double>> parseFreqList(
			const utils::OptionList& bounds,
			utils::Rainmeter::Logger& cl,
			const utils::Rainmeter& rain
		);

		void computeCascadesInfo(index fftSize, index cascadesCount);
		void calculateCascadeWeights(array_span<float> result, index fftBinsCount, double binWidth);

		void legacy_generateBandMultipliers();
	};
}
