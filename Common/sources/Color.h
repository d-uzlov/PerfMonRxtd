/*
 * Copyright (C) 2019-2020 rxtd
 *
 * This Source Code Form is subject to the terms of the GNU General Public
 * License; either version 2 of the License, or (at your option) any later
 * version. If a copy of the GPL was not distributed with this file, You can
 * obtain one at <https://www.gnu.org/licenses/gpl-2.0.html>.
 */

#pragma once
#include "IntMixer.h"

namespace rxtd::utils {
	// TODO check endianness at compile time
	union IntColor {
		struct {
			uint8_t b;
			uint8_t g;
			uint8_t r;
			uint8_t a;
		};

		uint32_t full;

		template<typename MixType, uint8_t precision>
		IntColor mixWith(IntColor other, IntMixer<MixType, precision> mixer) const {
			IntColor result;
			result.a = mixer.mix(a, other.a);
			result.r = mixer.mix(r, other.r);
			result.g = mixer.mix(g, other.g);
			result.b = mixer.mix(b, other.b);
			return result;
		}

		friend bool operator==(const IntColor& lhs, const IntColor& rhs) {
			return lhs.full == rhs.full;
		}

		friend bool operator!=(const IntColor& lhs, const IntColor& rhs) {
			return !(lhs == rhs);
		}
	};

	class Color {
		float red = 0.0;
		float green = 0.0;
		float blue = 0.0;
		float alpha = 1.0;

	public:
		Color() = default;

		Color(float red, float green, float blue, float alpha) :
			red(red),
			green(green),
			blue(blue),
			alpha(alpha) {
		}

		explicit Color(uint32_t value) {
			index a = (value >> 24) & 0xFF;
			index r = (value >> 16) & 0xFF;
			index g = (value >> 8) & 0xFF;
			index b = (value >> 0) & 0xFF;

			constexpr float coef = 1 / 255.0;
			alpha = a * coef;
			red = r * coef;
			green = g * coef;
			blue = b * coef;
		}

		Color(IntColor value) {
			constexpr float coef = 1 / 255.0;
			alpha = value.a * coef;
			red = value.r * coef;
			green = value.g * coef;
			blue = value.b * coef;
		}

		static Color mix(float percent, Color c1, Color c2) {
			return c1 * percent + c2 * (1.0f - percent);
		}

		Color operator*(float value) const {
			return { red * value, green * value, blue * value, alpha * value };
		}

		Color operator+(const Color& other) const {
			return { red + other.red, green + other.green, blue + other.blue, alpha + other.alpha };
		}

		// Doesn't alter alpha, unlike operator*
		Color amplify(float value) const {
			return { red * value, green * value, blue * value, alpha };
		}

		// autogenerated
		friend bool operator==(const Color& lhs, const Color& rhs) {
			return lhs.red == rhs.red
				&& lhs.green == rhs.green
				&& lhs.blue == rhs.blue
				&& lhs.alpha == rhs.alpha;
		}

		friend bool operator!=(const Color& lhs, const Color& rhs) {
			return !(lhs == rhs);
		}

		uint32_t toInt() const {
			const uint8_t r = uint8_t(std::clamp<float>(red * 255, 0.0, 255.0));
			const uint8_t g = uint8_t(std::clamp<float>(green * 255, 0.0, 255.0));
			const uint8_t b = uint8_t(std::clamp<float>(blue * 255, 0.0, 255.0));
			const uint8_t a = uint8_t(std::clamp<float>(alpha * 255, 0.0, 255.0));

			return a << 24 | r << 16 | g << 8 | b;
		}

		IntColor toIntColor() const {
			const uint8_t r = uint8_t(std::clamp<float>(red * 255, 0.0, 255.0));
			const uint8_t g = uint8_t(std::clamp<float>(green * 255, 0.0, 255.0));
			const uint8_t b = uint8_t(std::clamp<float>(blue * 255, 0.0, 255.0));
			const uint8_t a = uint8_t(std::clamp<float>(alpha * 255, 0.0, 255.0));

			return { b, g, r, a };
		}
	};
}
