/*
 * Copyright (C) 2019-2020 rxtd
 *
 * This Source Code Form is subject to the terms of the GNU General Public
 * License; either version 2 of the License, or (at your option) any later
 * version. If a copy of the GPL was not distributed with this file, You can
 * obtain one at <https://www.gnu.org/licenses/gpl-2.0.html>.
 */

#pragma once
#include "IntMixer.h"

namespace rxtd::utils {
	// TODO check endianness at compile time
	union IntColor {
		struct {
			uint8_t b;
			uint8_t g;
			uint8_t r;
			uint8_t a;
		};

		uint32_t full;

		template <typename MixType, uint8_t precision>
		IntColor mixWith(IntColor other, IntMixer<MixType, precision> mixer) const {
			IntColor result;
			result.a = mixer.mix(a, other.a);
			result.r = mixer.mix(r, other.r);
			result.g = mixer.mix(g, other.g);
			result.b = mixer.mix(b, other.b);
			return result;
		}

		friend bool operator==(const IntColor& lhs, const IntColor& rhs) {
			return lhs.full == rhs.full;
		}

		friend bool operator!=(const IntColor& lhs, const IntColor& rhs) {
			return !(lhs == rhs);
		}
	};

	class Color {
		union {
			struct {
				float red = 0.0;
				float green = 0.0;
				float blue = 0.0;
			} rgb{ };

			struct {
				float hue = 0.0;
				float sat = 0.0;
				float val = 0.0;
			} hsv;
		};

		float alpha = 1.0;

	public:
		Color() {
		}

		Color(float red, float green, float blue, float alpha) :
			alpha(alpha) {
			rgb.red = red;
			rgb.green = green;
			rgb.blue = blue;
		}

		Color(IntColor value) {
			constexpr float coef = 1 / 255.0;
			alpha = float(value.a) * coef;
			rgb.red = float(value.r) * coef;
			rgb.green = float(value.g) * coef;
			rgb.blue = float(value.b) * coef;
		}

		static Color mix(float percent, Color c1, Color c2) {
			return c1 * percent + c2 * (1.0f - percent);
		}

		[[nodiscard]]
		Color operator*(float value) const {
			return { rgb.red * value, rgb.green * value, rgb.blue * value, alpha * value };
		}

		[[nodiscard]]
		Color operator+(const Color& other) const {
			return {
				rgb.red + other.rgb.red, rgb.green + other.rgb.green, rgb.blue + other.rgb.blue, alpha + other.alpha
			};
		}

		// autogenerated
		friend bool operator==(const Color& lhs, const Color& rhs) {
			return lhs.rgb.red == rhs.rgb.red
				&& lhs.rgb.green == rhs.rgb.green
				&& lhs.rgb.blue == rhs.rgb.blue
				&& lhs.alpha == rhs.alpha;
		}

		friend bool operator!=(const Color& lhs, const Color& rhs) {
			return !(lhs == rhs);
		}

		[[nodiscard]]
		Color rgb2hsv() const {
			const float xMax = std::max(std::max(rgb.red, rgb.green), rgb.blue);
			const float xMin = std::min(std::min(rgb.red, rgb.green), rgb.blue);

			const float val = xMax;
			const float chroma = xMax - xMin;
			const float l = (xMax + xMin) * 0.5f;
			float hue = 0.0f;
			if (chroma == 0.0f) {
				hue = 0.0f;
			} else if (val == rgb.red) {
				hue = 60.0f * (rgb.green - rgb.blue) / chroma;
			} else if (val == rgb.green) {
				hue = 60.0f * (2.0f + (rgb.blue - rgb.red) / chroma);
			} else if (val == rgb.blue) {
				hue = 60.0f * (4.0f + (rgb.red - rgb.green) / chroma);
			}
			const float sat = val == 0.0f ? 0.0f : chroma / val;

			return { hue, sat, val, alpha };
		}

		[[nodiscard]]
		Color hsv2rgb() const {
			Color tmp;
			const float chroma = hsv.val * hsv.sat;
			const float h = hsv.hue * (1.0f / 60.0f);
			float _;
			const float hFraction = std::modff(h * 0.5f, &_) * 2.0f;
			const float x = chroma * (1.0f - std::abs(hFraction - 1.0f));

			if (chroma == 0.0) {
				tmp = { 0.0, 0.0, 0.0, alpha };
			} else if (h >= 0.0 && h <= 1.0) {
				tmp = { chroma, x, 0.0, alpha };
			} else if (h >= 1.0 && h <= 2.0) {
				tmp = { x, chroma, 0.0, alpha };
			} else if (h >= 2.0 && h <= 3.0) {
				tmp = { 0.0, chroma, x, alpha };
			} else if (h >= 3.0 && h <= 4.0) {
				tmp = { 0.0, x, chroma, alpha };
			} else if (h >= 4.0 && h <= 5.0) {
				tmp = { x, 0.0, chroma, alpha };
			} else {
				tmp = { chroma, 0.0, x, alpha };
			}

			const float m = hsv.val - chroma;
			return {
				tmp.rgb.red + m,
				tmp.rgb.green + m,
				tmp.rgb.blue + m,
				alpha
			};
		}

		[[nodiscard]]
		uint32_t toInt() const {
			const uint8_t r = uint8_t(std::clamp<float>(rgb.red * 255, 0.0, 255.0));
			const uint8_t g = uint8_t(std::clamp<float>(rgb.green * 255, 0.0, 255.0));
			const uint8_t b = uint8_t(std::clamp<float>(rgb.blue * 255, 0.0, 255.0));
			const uint8_t a = uint8_t(std::clamp<float>(alpha * 255, 0.0, 255.0));

			return a << 24 | r << 16 | g << 8 | b;
		}

		[[nodiscard]]
		IntColor toIntColor() const {
			const uint8_t r = uint8_t(std::clamp<float>(rgb.red * 255, 0.0, 255.0));
			const uint8_t g = uint8_t(std::clamp<float>(rgb.green * 255, 0.0, 255.0));
			const uint8_t b = uint8_t(std::clamp<float>(rgb.blue * 255, 0.0, 255.0));
			const uint8_t a = uint8_t(std::clamp<float>(alpha * 255, 0.0, 255.0));

			return { { b, g, r, a } };
		}
	};
}
