/*
 * Copyright (C) 2021 rxtd
 *
 * This Source Code Form is subject to the terms of the GNU General Public
 * License; either version 2 of the License, or (at your option) any later
 * version. If a copy of the GPL was not distributed with this file, You can
 * obtain one at <https://www.gnu.org/licenses/gpl-2.0.html>.
 */

#include "BufferPrinterExtensions.h"

#include "Audioclient.h"

sview HRESULT2string(HRESULT value) {
	switch (value) {
	case E_POINTER: return L"E_POINTER";
	case E_OUTOFMEMORY: return L"E_OUTOFMEMORY";
	case E_NOINTERFACE: return L"E_NOINTERFACE";
	case E_INVALIDARG: return L"E_INVALIDARG";

	case AUDCLNT_E_NOT_INITIALIZED: return L"AUDCLNT_E_NOT_INITIALIZED";
	case AUDCLNT_E_ALREADY_INITIALIZED: return L"AUDCLNT_E_ALREADY_INITIALIZED";
	case AUDCLNT_E_WRONG_ENDPOINT_TYPE: return L"AUDCLNT_E_WRONG_ENDPOINT_TYPE";
	case AUDCLNT_E_DEVICE_INVALIDATED: return L"AUDCLNT_E_DEVICE_INVALIDATED";
	case AUDCLNT_E_NOT_STOPPED: return L"AUDCLNT_E_NOT_STOPPED";
	case AUDCLNT_E_BUFFER_TOO_LARGE: return L"AUDCLNT_E_BUFFER_TOO_LARGE";
	case AUDCLNT_E_OUT_OF_ORDER: return L"AUDCLNT_E_OUT_OF_ORDER";
	case AUDCLNT_E_UNSUPPORTED_FORMAT: return L"AUDCLNT_E_UNSUPPORTED_FORMAT";
	case AUDCLNT_E_INVALID_SIZE: return L"AUDCLNT_E_INVALID_SIZE";
	case AUDCLNT_E_DEVICE_IN_USE: return L"AUDCLNT_E_DEVICE_IN_USE";
	case AUDCLNT_E_BUFFER_OPERATION_PENDING: return L"AUDCLNT_E_BUFFER_OPERATION_PENDING";
	case AUDCLNT_E_THREAD_NOT_REGISTERED: return L"AUDCLNT_E_THREAD_NOT_REGISTERED";
	case AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED: return L"AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED";
	case AUDCLNT_E_ENDPOINT_CREATE_FAILED: return L"AUDCLNT_E_ENDPOINT_CREATE_FAILED";
	case AUDCLNT_E_SERVICE_NOT_RUNNING: return L"AUDCLNT_E_SERVICE_NOT_RUNNING";
	case AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED: return L"AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED";
	case AUDCLNT_E_EXCLUSIVE_MODE_ONLY: return L"AUDCLNT_E_EXCLUSIVE_MODE_ONLY";
	case AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL: return L"AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL";
	case AUDCLNT_E_EVENTHANDLE_NOT_SET: return L"AUDCLNT_E_EVENTHANDLE_NOT_SET";
	case AUDCLNT_E_INCORRECT_BUFFER_SIZE: return L"AUDCLNT_E_INCORRECT_BUFFER_SIZE";
	case AUDCLNT_E_BUFFER_SIZE_ERROR: return L"AUDCLNT_E_BUFFER_SIZE_ERROR";
	case AUDCLNT_E_CPUUSAGE_EXCEEDED: return L"AUDCLNT_E_CPUUSAGE_EXCEEDED";
	case AUDCLNT_E_BUFFER_ERROR: return L"AUDCLNT_E_BUFFER_ERROR";
	case AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED: return L"AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED";
	case AUDCLNT_E_INVALID_DEVICE_PERIOD: return L"AUDCLNT_E_INVALID_DEVICE_PERIOD";
	case AUDCLNT_E_INVALID_STREAM_FLAG: return L"AUDCLNT_E_INVALID_STREAM_FLAG";
	case AUDCLNT_E_ENDPOINT_OFFLOAD_NOT_CAPABLE: return L"AUDCLNT_E_ENDPOINT_OFFLOAD_NOT_CAPABLE";
	case AUDCLNT_E_OUT_OF_OFFLOAD_RESOURCES: return L"AUDCLNT_E_OUT_OF_OFFLOAD_RESOURCES";
	case AUDCLNT_E_OFFLOAD_MODE_ONLY: return L"AUDCLNT_E_OFFLOAD_MODE_ONLY";
	case AUDCLNT_E_NONOFFLOAD_MODE_ONLY: return L"AUDCLNT_E_NONOFFLOAD_MODE_ONLY";
	case AUDCLNT_E_RESOURCES_INVALIDATED: return L"AUDCLNT_E_RESOURCES_INVALIDATED";
	case AUDCLNT_E_RAW_MODE_UNSUPPORTED: return L"AUDCLNT_E_RAW_MODE_UNSUPPORTED";
	case AUDCLNT_E_ENGINE_PERIODICITY_LOCKED: return L"AUDCLNT_E_ENGINE_PERIODICITY_LOCKED";
	case AUDCLNT_E_ENGINE_FORMAT_LOCKED: return L"AUDCLNT_E_ENGINE_FORMAT_LOCKED";
	case AUDCLNT_E_HEADTRACKING_ENABLED: return L"AUDCLNT_E_HEADTRACKING_ENABLED";
	case AUDCLNT_E_HEADTRACKING_UNSUPPORTED: return L"AUDCLNT_E_HEADTRACKING_UNSUPPORTED";

	default: return {};
	}
}

void utils::writeType(std::wostream& stream, const HRESULT& hr, sview options) {
	auto name = HRESULT2string(hr);
	if (!name.empty()) {
		stream << name;
	} else {
		stream << hr;
	}
}
